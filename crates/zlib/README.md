# ZLIB Compressed Data Format

Deflate圧縮を用いた圧縮データフォーマット

Deflate圧縮は内部ではLZ77(辞書式圧縮)とハフマンコーディング(エントロピー符号)
を用いた可逆圧縮手法

- 仕様書:
    - ZLib: https://www.rfc-editor.org/rfc/rfc1950
    - Deflate: https://www.rfc-editor.org/rfc/rfc1951

# ハフマン符号

頻出のデータパターンに短い符号(コード)を割り当てることで、データを圧縮するエントロピー符号の一種。

deflateで使うハフマン符号には追加のルールが有る

- 短いコードは長いコードより辞書順で前になければならない
- 同じ長さのコードは辞書順で連続していなければならない
- 同じ長さのコードの辞書順は、そのコードが表す値の辞書順と一致していなければならない

例 A,B,C,Dの4文字を符号化した次のコードを考える

| 文字 | コードパターン1 | コードパターン2 | コードパターン3 | コードパターン4 |
|----|----------|----------|----------|----------|
| A  | 1        | 00       | 0        | 0        |
| B  | 01       | 01       | 10       | 10       |
| C  | 001      | 11       | 111      | 110      |
| D  | 000      | 101      | 110      | 111      |

- コードパターン1は短いコード (`1`) が長いコード (`01`) より辞書順で後ろになっているため不正なコードパターンである。
- コードパターン2は長さ2のコード (`01`と`11`) が辞書順で連続していないため不正なコードパターンである。
- コードパターン3はCのコード (`111`) とDのコード (`110`) が辞書順で逆になっているため不正なコードパターンである。

このようなルールのもとではコードの長さのリストから符号を一意に求めることができる。

例: 各文字のコード長が `A=1, B=2, C=3, D=3` の場合、 コードは必ず `A=0, B=10, C=110, D=111` となる。

アルゴリズム:

1. コード長最短の文字に0から順にコードを割り当てる

   `A=0、(次のコード)=1`

2. コード長を進める際はビットシフトする

   `コード長2へ: (次のコード)=10`

3. 以下同様にコードを割り当てる

    - `B=10、(次のコード)=11`
    - `コード長3へ: (次のコード)=110`
    - `C=110、(次のコード)=111`
    - `D=111`

Deflate圧縮では、圧縮に使用したハフマン符号表を「コード長のリスト」の形で保持している。

# ファイル構造

ZLIBフォーマットのヘッダ2byteに続きDeflate圧縮されたデータが続く。

データは1つ以上のブロックと呼ばれるデータの列で構成され、3種類のブロックが存在する

- 非圧縮ブロック
    - 圧縮されていないデータブロック
- 固定ハフマン符号圧縮
    - 予め仕様で決められたハフマン符号で圧縮されたブロック
- 動的ハフマン符号圧縮
    - 独自のハフマン符号で圧縮されたブロック。ブロックの先頭にハフマン符号の定義が含まれる。

各ブロックの先頭3bitはヘッダーである

先頭1ビットは `BFINAL` フラグで、このブロックが最後のブロックかどうかを示す。

次の2ビットは圧縮アルゴリズムを示す

- 00: 非圧縮
- 01: 固定ハフマン符号圧縮
- 10: 動的ハフマン符号圧縮
- 11: 予約済み,未使用

## 非圧縮ブロック

現在の読み出し位置がバイト境界でない場合は、残りのbitはすべて無視して次のバイトまで移動する。

先頭2バイト `LEN` はデータのバイトサイズを表す。 次の2バイト `NLEN` は `LEN` のビット反転を表す。

その後、長さ `LEN` の無圧縮なバイト列が続く。

## 圧縮ブロック

圧縮はバイト単位で行われ、2種類のコードへと変換されている。

- リテラルコード
    - 直前32KB中に重複がなかったバイト。データがそのままコードとして圧縮ブロックに含まれている。
    - コード値 0-255
- ブロックの終端
    - コード値 256
- ポインタコード
    - 直前32KB中に重複があったバイト。重複データへのポインタで表現される
    - ポインタは (重複データの長さ、重複データまでの距離) の組で表現される
    - 長さは258byteまで、距離は32KBまで表現可能
    - 重複文字列の長さ (3-258)
        - コード値 257-285 (8bit)
        - 28種類のコードで256種類の長さを表現するために、コードの値に応じて必要な追加bitを読み込む。
            - 例: コード値257は長さ3を表すため追加bitは不要。
            - 例: コード値276は長さ59~66のいずれかを表す。追加で3bit(0~7)を読み込み59を足す。
            - 読むべき追加ビット数については仕様書参照
    - 重複文字列までの距離 (1-32768)
        - コード値 0-29
        - リテラルとコードが重複しているが必ず「長さ」コードのあとに現れるため識別可能
        - 長さと同様、追加bitを読み込む。

### 固定ハフマン符号圧縮

長さ、リテラルを圧縮するハフマン符号表が予め仕様で決められている。
距離は符号化せずにそのまま保持されている。

具体的なコード定義は仕様書参照

### 動的ハフマン符号圧縮

長さ、距離、リテラルがすべて独自のハフマン符号表で符号化されている。
長さとリテラルは同じ符号表で、距離は別の符号表で符号化されている。

ヘッダのあとに3種類のハフマン符号のパターン定義が続く。

- 以下2つの「コード長リスト」を圧縮する符号表のコード長リスト
- リテラル・長さを圧縮する符号表のコード長リスト
- 距離を圧縮する符号表のコード長リスト

#### 「コード長リスト」符号表のコード長リスト

「コード長リスト」とは例えば次のようなもの

```text
15, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 15, 15, 15
```

この場合、

- 0を表すコードの長さは15bit
- 1を表すコードの長さは14bit
- ...

といった意味になる。

このコード長リスト自体をさらに圧縮する。

```text
15, 14, 16(0), 17(3), 15, 15, 15
```

- 0 - 15: コードの長さ(16bit以上のコードは非対応)
- 16: 続く2bitを読み(0-3)、3を加えた値(3-6)だけ直前のコード長を繰り返す
    - 例: `14, 16(0)`
        - 14 = コード長14
        - 16(0) = 0+3=3回直前のコード長14を繰り返す
        - つまり、長さ14のコードが合計1+3=4個あることを示す
- 17: 追加3bitを読み(0-7)、3を加えた値(3-10)だけ長さ0を繰り返す
- 18: 追加7bitを読み(0-127)、11を加えた値(11-138)だけ長さ0を繰り返す

これを踏まえブロックのレイアウトは次の通り

- `5 bits` HLIT: (リテラル・長さコードの数)-257
- `5 bits` HDIST: (距離コードの数)-1
- `4 bits` HCLEN: (コード長コードの数)-4
- `(HCLEN+4)*3 bits` 「コード長コード」のコード長リスト
    - 例: コード長コード8は長さ3のコードで表現される、など。
- `HLIT+257`個のリテラルコード長のリスト(コード長コードでハフマン符号化済み)
- `HDIST+1`個の距離コード長のリスト(コード長コードでハフマン符号化済み)
- 実際の圧縮済みデータ
- リテラルコード256: ブロックの終端(リテラルコードでハフマン符号化済み)

リテラルコード長リストと距離コード長リストは連続しており、
距離コード長リストがリテラルコード長リストを参照する場合がある。

言い換えると長さ `HLIT+HDIST+258`のコード長リストがあり、
その前半`HLIT+257`個がリテラルコード用のコード長リストである

重複文字列の圧縮について、参照文字列と出力文字列が重複している場合がある

例 `X, Y, <長さ5,距離2>` という圧縮済みデータ列からは `X, Y, X, Y, X, Y, X` というデータが得られる

